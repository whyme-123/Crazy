<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Questions and Answers</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body class="dark">

    <div class="container dark">
        <div class="button-container">
            <button class="copy-all dark" onclick="copyAll()">Copy All</button>
            <button class="toggle-theme dark" onclick="toggleTheme()">☀</button>
        </div>

        <div class="qa-section">
            <div class="qa-item">
                <label for="qa1">Hard Question 1 & Answer:</label>
                <pre id="qa1" class="dark">
                    


Write down the SQL query considering below schema of Apple store database
Customer (Customer_id, first_name, Last_name)
Payment (Customer_id, Product_id, Payment_id, amount, Payment_date)
Product (Product_id, Product_name, Product_type, Color)
Create tables with Primary Key, foreign key constraints in given schemas.
i. Give the name of customers who have made the payment in the middle of 1st Aug 2023 to 10th Aug 2023.
ii. Give the list of product name whose color is red and type is iPhone.
iii. Give all the product names and product types which were bought by Shyam Patel.
iv. Give the first name of customers whose total payment is greater than 2 lac rupees.

-- Create the Customer table with a primary key
CREATE TABLE Customer (
    Customer_id INT PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50)
);

-- Create the Product table with a primary key
CREATE TABLE Product (
    Product_id INT PRIMARY KEY,
    Product_name VARCHAR(50),
    Product_type VARCHAR(50),
    Color VARCHAR(20)
);

-- Create the Payment table with primary key and foreign key constraints
CREATE TABLE Payment (
    Payment_id INT PRIMARY KEY,
    Customer_id INT,
    Product_id INT,
    amount DECIMAL(10, 2),
    Payment_date DATE,
    FOREIGN KEY (Customer_id) REFERENCES Customer(Customer_id),
    FOREIGN KEY (Product_id) REFERENCES Product(Product_id)
);

-- 1. Customers who made payments between 1st Aug 2023 and 10th Aug 2023
SELECT C.first_name, C.last_name
FROM Customer C
JOIN Payment P ON C.Customer_id = P.Customer_id
WHERE P.Payment_date BETWEEN '2023-08-01' AND '2023-08-10';

-- 2. List of product names with red color and type iPhone
SELECT Product_name
FROM Product
WHERE Color = 'Red' AND Product_type = 'iPhone';

-- 3. Product names and types bought by Shyam Patel
SELECT Pr.Product_name, Pr.Product_type
FROM Product Pr
JOIN Payment Pa ON Pr.Product_id = Pa.Product_id
JOIN Customer Cu ON Pa.Customer_id = Cu.Customer_id
WHERE Cu.first_name = 'Shyam' AND Cu.last_name = 'Patel';

-- 4. First names of customers with total payment greater than 2 lakh rupees
SELECT C.first_name
FROM Customer C
JOIN Payment P ON C.Customer_id = P.Customer_id
GROUP BY C.Customer_id, C.first_name
HAVING SUM(P.amount) > 200000;


———————————————————————————————————————————————————————————————————————————


Write SQL query considering below schema of database
Film(film_id, title, legth, rental_rate), Actor(film_id, actor_id, first_name, last_name)
Category(film_id, rating, language, release_year)
Create tables with Primary Key, foreign key constraints in given schemas.
i.Give the name of actors whose actor id is 23.
ii.Give the title of films whose id is between 25 and 40.
iii.Give the name of actor whose last name contains Kapoor.
iv.Give the title of film which was released in 2022.
v.Give the name of actors played who have role in film title ‘Chhello divas’.

-- Create the Film table with a primary key
CREATE TABLE Film (
    film_id INT PRIMARY KEY,
    title VARCHAR(100),
    length INT,
    rental_rate DECIMAL(5, 2)
);

-- Create the Actor table with a primary key and foreign key constraint
CREATE TABLE Actor (
    actor_id INT PRIMARY KEY,
    film_id INT,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    FOREIGN KEY (film_id) REFERENCES Film(film_id)
);

-- Create the Category table with a primary key and foreign key constraint
CREATE TABLE Category (
    film_id INT PRIMARY KEY,
    rating VARCHAR(10),
    language VARCHAR(50),
    release_year INT,
    FOREIGN KEY (film_id) REFERENCES Film(film_id)
);

-- 1. Names of actors whose actor id is 23
SELECT first_name, last_name
FROM Actor
WHERE actor_id = 23;

-- 2. Titles of films whose id is between 25 and 40
SELECT title
FROM Film
WHERE film_id BETWEEN 25 AND 40;

-- 3. Name of actor whose last name contains 'Kapoor'
SELECT first_name, last_name
FROM Actor
WHERE last_name LIKE '%Kapoor%';

-- 4. Titles of films released in 2022
SELECT title
FROM Film
JOIN Category ON Film.film_id = Category.film_id
WHERE Category.release_year = 2022;

-- 5. Names of actors who played a role in the film titled ‘Chhello divas’
SELECT A.first_name, A.last_name
FROM Actor A
JOIN Film F ON A.film_id = F.film_id
WHERE F.title = 'Chhello divas';


———————————————————————————————————————————————————————————————————————————

Consider following schema and write query for given statement
Emp (eid,ename,city,dname,salary) Project(eid,pid,pname,location)
Create tables with Primary Key, foreign key constraints in given schemas.
(1) Display name of employees who belongs to Computer department.
(2) Display employee id whose name starts from letter J.
(3) Display all details of employees whose salary is from 10000 to 20000.
(4) Display name of employees who are having maximum salary.
(5) Display name of employees whose salary is higher than average salary of the employee.
(6) Display name of employees whose project id is 3 and location is Mumbai.

-- Create the Emp table with a primary key
CREATE TABLE Emp (
    eid INT PRIMARY KEY,
    ename VARCHAR(50),
    city VARCHAR(50),
    dname VARCHAR(50),
    salary DECIMAL(10, 2)
);

-- Create the Project table with a primary key and foreign key constraint
CREATE TABLE Project (
    eid INT,
    pid INT,
    pname VARCHAR(50),
    location VARCHAR(50),
    PRIMARY KEY (eid, pid),
    FOREIGN KEY (eid) REFERENCES Emp(eid)
);

-- (1) Display name of employees who belong to the Computer department
SELECT ename
FROM Emp
WHERE dname = 'Computer';

-- (2) Display employee id whose name starts with the letter J
SELECT eid
FROM Emp
WHERE ename LIKE 'J%';

-- (3) Display all details of employees whose salary is from 10000 to 20000
SELECT *
FROM Emp
WHERE salary BETWEEN 10000 AND 20000;

-- (4) Display name of employees who are having the maximum salary
SELECT ename
FROM Emp
WHERE salary = (SELECT MAX(salary) FROM Emp);

-- (5) Display name of employees whose salary is higher than the average salary of the employees
SELECT ename
FROM Emp
WHERE salary > (SELECT AVG(salary) FROM Emp);

-- (6) Display name of employees whose project id is 3 and location is Mumbai
SELECT E.ename
FROM Emp E
JOIN Project P ON E.eid = P.eid
WHERE P.pid = 3 AND P.location = 'Mumbai';


———————————————————————————————————————————————————————————————————————————

A) We have following relation orders(order_id,customer_id,order_date,amount). Create table with Primary Key, other
relevant constraints in given schema.
1) Find out the number of orders for each customer by customer_id and show only customer_id with number of orders above 5.
2) Find out the total amount by order_id and order_date.
B) Find the sum of a user-inserted number's first and last digits using PL/pgSQL function.

-- Part A: SQL Queries

-- 1. Create the Orders table with a primary key and relevant constraints
CREATE TABLE Orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    order_date DATE,
    amount DECIMAL(10, 2)
);

-- 2. Find out the number of orders for each customer by customer_id and show only customer_id with the number of orders above 5
SELECT customer_id, COUNT(*) AS number_of_orders
FROM Orders
GROUP BY customer_id
HAVING COUNT(*) > 5;

-- 3. Find out the total amount by order_id and order_date
SELECT order_id, order_date, SUM(amount) AS total_amount
FROM Orders
GROUP BY order_id, order_date;

-- Part B: PL/pgSQL Function

-- Create a PL/pgSQL function to find the sum of the first and last digits of a user-inserted number
CREATE OR REPLACE FUNCTION sum_first_last_digit(num INT) RETURNS INT AS $$
DECLARE
    first_digit INT;
    last_digit INT;
    result INT;
BEGIN
    -- Extract the last digit
    last_digit := num % 10;
    
    -- Extract the first digit
    first_digit := num;
    WHILE first_digit >= 10 LOOP
        first_digit := first_digit / 10;
    END LOOP;
    
    -- Calculate the result as the sum of first and last digits
    result := first_digit + last_digit;
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Usage Example (Execute this to test the function)
SELECT sum_first_last_digit(12345); -- This will return 6 (1 + 5)

———————————————————————————————————————————————————————————————————————————

Write a query for the following.
employee(eid,name, salary, address) department(d_id, d_name, eid)
Give Primary Key, foreign key constraints after creating table with constraint names in given schemas.
(1) Create a view department_details of department table.
(2) Join two existing tables using inner join.
(3) To drop a view.

-- Create the Employee table with a primary key
CREATE TABLE Employee (
    eid INT PRIMARY KEY CONSTRAINT pk_employee_id,
    name VARCHAR(50),
    salary DECIMAL(10, 2),
    address VARCHAR(100)
);

-- Create the Department table with a primary key and foreign key constraint
CREATE TABLE Department (
    d_id INT PRIMARY KEY CONSTRAINT pk_department_id,
    d_name VARCHAR(50),
    eid INT,
    FOREIGN KEY (eid) REFERENCES Employee(eid) CONSTRAINT fk_employee_id
);

-- 1. Create a view department_details of the Department table
CREATE VIEW department_details AS
SELECT d_id, d_name, eid
FROM Department;

-- 2. Join two existing tables using an inner join
SELECT e.eid, e.name, e.salary, e.address, d.d_id, d.d_name
FROM Employee e
INNER JOIN Department d ON e.eid = d.eid;

-- 3. To drop the view
DROP VIEW IF EXISTS department_details;

———————————————————————————————————————————————————————————————————————————

A) Write PL/pgSQL function to increment the employee’s salary by 10% if his/her department is ‘HR’ for given(inputted)
employee_id.
Schema: Employee(employee_id, first_name, last_name, department, salary)
B) Write PL/pgSQL function to find the number of Sundays between given dates.

-- A) PL/pgSQL Function to Increment Employee's Salary by 10% if Department is ‘HR’

CREATE OR REPLACE FUNCTION increment_salary_if_hr(employee_id INT) RETURNS VOID AS $$
BEGIN
    -- Check if the department of the employee is 'HR'
    IF EXISTS (
        SELECT 1
        FROM Employee
        WHERE employee_id = employee_id
        AND department = 'HR'
    ) THEN
        -- Update the salary by increasing it by 10%
        UPDATE Employee
        SET salary = salary * 1.10
        WHERE employee_id = employee_id;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- B) PL/pgSQL Function to Find the Number of Sundays Between Given Dates

CREATE OR REPLACE FUNCTION count_sundays(start_date DATE, end_date DATE) RETURNS INT AS $$
DECLARE
    sunday_count INT := 0;
    current_date DATE;
BEGIN
    -- Initialize the current_date to the start_date
    current_date := start_date;
    
    -- Loop through the date range
    WHILE current_date <= end_date LOOP
        -- Check if the current_date is a Sunday
        IF EXTRACT(DOW FROM current_date) = 0 THEN
            sunday_count := sunday_count + 1;
        END IF;
        -- Move to the next date
        current_date := current_date + INTERVAL '1 day';
    END LOOP;
    
    RETURN sunday_count;
END;
$$ LANGUAGE plpgsql;

———————————————————————————————————————————————————————————————————————————

Write pl/pgSQL block using Explicit cursor to insert the whole tuple from Film table to Film_pay table if amount is greater than
$10.
Schema: Film (film_id, title, length, amount,rating)

-- Create Film_pay table if it does not exist
CREATE TABLE IF NOT EXISTS Film_pay (
    film_id INT,
    title VARCHAR(100),
    length INT,
    amount DECIMAL(10, 2),
    rating VARCHAR(10)
);

-- PL/pgSQL Block to Insert Records Using an Explicit Cursor
DO $$
DECLARE
    -- Define the explicit cursor
    CURSOR film_cursor IS
        SELECT film_id, title, length, amount, rating
        FROM Film
        WHERE amount > 10;
        
    -- Define a record type to hold the cursor row
    film_record film_cursor%ROWTYPE;
BEGIN
    -- Open the cursor
    OPEN film_cursor;
    
    -- Loop through the cursor results
    LOOP
        -- Fetch a row into the film_record
        FETCH film_cursor INTO film_record;
        EXIT WHEN NOT FOUND; -- Exit the loop when no more rows
        
        -- Insert the record into the Film_pay table
        INSERT INTO Film_pay (film_id, title, length, amount, rating)
        VALUES (film_record.film_id, film_record.title, film_record.length, film_record.amount, film_record.rating);
    END LOOP;
    
    -- Close the cursor
    CLOSE film_cursor;
END;
$$ LANGUAGE plpgsql;

———————————————————————————————————————————————————————————————————————————

Calculate the total price (numeric) of all products with a product price greater than Rs. 500 using a cursor from following
Schema: Products (p_id int, p_name varchar (100), price numeric). Display all product name and price with total price of
products.

-- 1. Create the Products table
CREATE TABLE Products (
    p_id INT PRIMARY KEY,
    p_name VARCHAR(100),
    price NUMERIC
);

-- 2. Insert some example data into the Products table
INSERT INTO Products (p_id, p_name, price) VALUES
(1, 'Product A', 450),
(2, 'Product B', 600),
(3, 'Product C', 700),
(4, 'Product D', 300),
(5, 'Product E', 800);

-- 3. PL/pgSQL Block to Calculate Total Price Using an Explicit Cursor
DO $$
DECLARE
    -- Define the explicit cursor
    CURSOR product_cursor IS
        SELECT p_name, price
        FROM Products
        WHERE price > 500;
        
    -- Define variables to hold cursor data and the total price
    product_record product_cursor%ROWTYPE;
    total_price NUMERIC := 0;
BEGIN
    -- Open the cursor
    OPEN product_cursor;
    
    -- Loop through the cursor results
    LOOP
        -- Fetch a row into the product_record
        FETCH product_cursor INTO product_record;
        EXIT WHEN NOT FOUND; -- Exit the loop when no more rows
        
        -- Update the total price
        total_price := total_price + product_record.price;
        
        -- Display the product name and price
        RAISE NOTICE 'Product Name: %, Price: %', product_record.p_name, product_record.price;
    END LOOP;
    
    -- Close the cursor
    CLOSE product_cursor;
    
    -- Display the total price of products
    RAISE NOTICE 'Total Price of Products with price > 500: %', total_price;
END;
$$ LANGUAGE plpgsql;

———————————————————————————————————————————————————————————————————————————

Create PL/pgSQL procedure for the increment of employees where in salary less than 35000 will get hike of 15% in their previous
salary and other will get 10% hike in their previous salary. Using following schema, Employees (id, name, department, salary)
call the procedure by id and print employee’s name with their updated salary.

-- Create the Employees table if it does not exist
CREATE TABLE IF NOT EXISTS Employees (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    department VARCHAR(50),
    salary NUMERIC
);
-- Create a PL/pgSQL procedure to update employee salaries
CREATE OR REPLACE PROCEDURE update_employee_salary(employee_id INT) 
LANGUAGE plpgsql
AS $$
BEGIN
    -- Update salaries based on the given condition
    UPDATE Employees
    SET salary = CASE 
        WHEN salary < 35000 THEN salary * 1.15  -- 15% hike
        ELSE salary * 1.10                      -- 10% hike
    END
    WHERE id = employee_id;

    -- Print the employee's name and updated salary
    RAISE NOTICE 'Employee ID: %, Name: %, Updated Salary: %',
        employee_id,
        (SELECT name FROM Employees WHERE id = employee_id),
        (SELECT salary FROM Employees WHERE id = employee_id);
END;
$$;
-- Call the procedure for employee with ID 1
CALL update_employee_salary(1);

———————————————————————————————————————————————————————————————————————————

A) Write PL/pgSQL program that calculates the factorial of a number=5 using a loop.
B) Write PL/pgSQL program to calculate the sum of first 100 even numbers

-- PL/pgSQL Block to Calculate the Factorial of a Number = 5
DO $$
DECLARE
    num INT := 5;         -- Number to calculate factorial for
    factorial INT := 1;  -- Initialize factorial to 1
    i INT;                -- Loop counter
BEGIN
    -- Loop to calculate factorial
    FOR i IN 1..num LOOP
        factorial := factorial * i;
    END LOOP;

    -- Print the result
    RAISE NOTICE 'Factorial of % is %', num, factorial;
END;
$$ LANGUAGE plpgsql;

-- PL/pgSQL Block to Calculate the Sum of the First 100 Even Numbers
DO $$
DECLARE
    count INT := 100;     -- Number of even numbers to sum
    sum_even NUMERIC := 0;  -- Initialize sum
    i INT;                -- Loop counter
BEGIN
    -- Loop to calculate the sum of even numbers
    FOR i IN 1..count LOOP
        sum_even := sum_even + (i * 2);  -- Add the ith even number to sum
    END LOOP;

    -- Print the result
    RAISE NOTICE 'Sum of the first % even numbers is %', count, sum_even;
END;
$$ LANGUAGE plpgsql;

———————————————————————————————————————————————————————————————————————————

Write a PL/pgSQL block using an explicit cursor that will transfer the record of account no, customer name and balance from the
“account” table to the “branch_surat” table if the branch name is surat in the “account” table. Furthermore, delete the record from
the “account” table whichever record transfers to the “branch_surat” table.
Use the following tables:
account (ano, customer_name, balance, branch_name)
branch_surat (ano, customer_name, balance)
Create tables with Primary Key, foreign key constraints in given schemas.

-- Create the account table
CREATE TABLE account (
    ano INT PRIMARY KEY,
    customer_name VARCHAR(100),
    balance NUMERIC,
    branch_name VARCHAR(100)
);

-- Create the branch_surat table
CREATE TABLE branch_surat (
    ano INT PRIMARY KEY,
    customer_name VARCHAR(100),
    balance NUMERIC
);
-- PL/pgSQL Block to Transfer Records and Delete from Original Table
DO $$
DECLARE
    -- Define the explicit cursor
    CURSOR account_cursor IS
        SELECT ano, customer_name, balance
        FROM account
        WHERE branch_name = 'surat';

    -- Define a record type to hold cursor data
    account_record account_cursor%ROWTYPE;
BEGIN
    -- Open the cursor
    OPEN account_cursor;

    -- Loop through the cursor results
    LOOP
        -- Fetch a row into the account_record
        FETCH account_cursor INTO account_record;
        EXIT WHEN NOT FOUND; -- Exit the loop when no more rows

        -- Insert the record into the branch_surat table
        INSERT INTO branch_surat (ano, customer_name, balance)
        VALUES (account_record.ano, account_record.customer_name, account_record.balance);

        -- Delete the record from the account table
        DELETE FROM account
        WHERE ano = account_record.ano;
    END LOOP;

    -- Close the cursor
    CLOSE account_cursor;
END;
$$ LANGUAGE plpgsql;

———————————————————————————————————————————————————————————————————————————

In PostgreSQL, create a PL/pgSQL block that defines a procedure named
update_employee_salary which takes two parameters: employee_id and new_salary. This procedure should update the salary of
the employee with the given employee_id to the new salary value. Assume “employee” table with fields – eid, ename and salary.

-- Create the employee table if it does not exist
CREATE TABLE IF NOT EXISTS employee (
    eid INT PRIMARY KEY,
    ename VARCHAR(100),
    salary NUMERIC
);
-- Create or replace the procedure to update employee salary
CREATE OR REPLACE PROCEDURE update_employee_salary(
    employee_id INT,
    new_salary NUMERIC
) 
LANGUAGE plpgsql
AS $$
BEGIN
    -- Update the salary of the employee with the given ID
    UPDATE employee
    SET salary = new_salary
    WHERE eid = employee_id;

    -- Check if the employee ID exists and display a message
    IF FOUND THEN
        RAISE NOTICE 'Employee ID: %, Salary updated to: %', employee_id, new_salary;
    ELSE
        RAISE NOTICE 'Employee ID: % not found', employee_id;
    END IF;
END;
$$;
-- Call the procedure to update the salary of employee with ID 1 to 50000
CALL update_employee_salary(1, 50000);

———————————————————————————————————————————————————————————————————————————

Consider following schema and write SQL for given statements.
title (id,designation,DOJ), bonus(id,bonus_date,amount)
Create tables with Primary Key, foreign key constraints in given schemas.
1)Retrieve the employees who haven't received any bonuses.
2)Retrieve the total bonus amount received by each employee.
3)Retrieve the highest bonus amount received.
4)List out id's whose bonus amount is at most 4000 and designation is admin.

-- Create the title table
CREATE TABLE title (
    id INT PRIMARY KEY,
    designation VARCHAR(100),
    DOJ DATE
);

-- Create the bonus table
CREATE TABLE bonus (
    id INT,
    bonus_date DATE,
    amount NUMERIC,
    FOREIGN KEY (id) REFERENCES title(id)  -- Foreign key constraint
);
SELECT t.id, t.designation, t.DOJ
FROM title t
LEFT JOIN bonus b ON t.id = b.id
WHERE b.id IS NULL;

SELECT t.id, t.designation, COALESCE(SUM(b.amount), 0) AS total_bonus
FROM title t
LEFT JOIN bonus b ON t.id = b.id
GROUP BY t.id, t.designation;

SELECT MAX(amount) AS highest_bonus
FROM bonus;

SELECT DISTINCT t.id
FROM title t
JOIN bonus b ON t.id = b.id
WHERE b.amount <= 4000 AND t.designation = 'admin';

———————————————————————————————————————————————————————————————————————————

Consider following schema and write SQL for given statements.
Student (RollNo, Name, DeptCode, City), Department (DeptCode, DeptName), Result (RollNo, Semester, SPI)
Create tables with Primary Key, foreign key constraints in given schemas.
1)Retrieve all student names and their respective department names.
2)Retrieve the average SPI (Semester Performance Index) for each student.
3)Retrieve the students who have the highest SPI semester -wise.
4)Retrieve the students who belong to a Ahmedabad city with their department names.

-- Create the Department table
CREATE TABLE Department (
    DeptCode VARCHAR(10) PRIMARY KEY,
    DeptName VARCHAR(100)
);

-- Create the Student table
CREATE TABLE Student (
    RollNo INT PRIMARY KEY,
    Name VARCHAR(100),
    DeptCode VARCHAR(10),
    City VARCHAR(100),
    FOREIGN KEY (DeptCode) REFERENCES Department(DeptCode)
);

-- Create the Result table
CREATE TABLE Result (
    RollNo INT,
    Semester INT,
    SPI NUMERIC,
    PRIMARY KEY (RollNo, Semester),
    FOREIGN KEY (RollNo) REFERENCES Student(RollNo)
);

-- 1) Retrieve all student names and their respective department names
SELECT s.Name, d.DeptName
FROM Student s
JOIN Department d ON s.DeptCode = d.DeptCode;

-- 2) Retrieve the average SPI (Semester Performance Index) for each student
SELECT s.RollNo, s.Name, COALESCE(AVG(r.SPI), 0) AS Average_SPI
FROM Student s
LEFT JOIN Result r ON s.RollNo = r.RollNo
GROUP BY s.RollNo, s.Name;

-- 3) Retrieve the students who have the highest SPI semester-wise
WITH Max_SPI_Per_Semester AS (
    SELECT Semester, MAX(SPI) AS Max_SPI
    FROM Result
    GROUP BY Semester
)
SELECT s.RollNo, s.Name, r.Semester, r.SPI
FROM Result r
JOIN Student s ON r.RollNo = s.RollNo
JOIN Max_SPI_Per_Semester mspi ON r.Semester = mspi.Semester AND r.SPI = mspi.Max_SPI;

-- 4) Retrieve the students who belong to Ahmedabad city with their department names
SELECT s.Name, d.DeptName
FROM Student s
JOIN Department d ON s.DeptCode = d.DeptCode
WHERE s.City = 'Ahmedabad';

———————————————————————————————————————————————————————————————————————————

Consider following relations:
Supplier(S#,sname,status,city), Parts(P#,pname,color,weight,city), SP(S#,P#,quantity)
Create tables with Primary Key, foreign key constraints in given schemas.
Answer the following queries.
(1) Find name of suppliers who supply ‘GREEN’ parts.
(2) Count number of suppliers who supply ‘RED’ parts and deliver in Surat city only.
(3) Sort the supplier table by sname.
(4) List suppliers who supply parts to more than one city.

-- Create the Supplier table
CREATE TABLE Supplier (
    S# INT PRIMARY KEY,
    sname VARCHAR(100),
    status INT,
    city VARCHAR(100)
);

-- Create the Parts table
CREATE TABLE Parts (
    P# INT PRIMARY KEY,
    pname VARCHAR(100),
    color VARCHAR(50),
    weight NUMERIC,
    city VARCHAR(100)
);

-- Create the SP table
CREATE TABLE SP (
    S# INT,
    P# INT,
    quantity INT,
    FOREIGN KEY (S#) REFERENCES Supplier(S#),
    FOREIGN KEY (P#) REFERENCES Parts(P#),
    PRIMARY KEY (S#, P#)
);

-- 1) Find the name of suppliers who supply ‘GREEN’ parts
SELECT DISTINCT s.sname
FROM Supplier s
JOIN SP sp ON s.S# = sp.S#
JOIN Parts p ON sp.P# = p.P#
WHERE p.color = 'GREEN';

-- 2) Count the number of suppliers who supply ‘RED’ parts and deliver in Surat city only
SELECT COUNT(DISTINCT s.S#) AS SupplierCount
FROM Supplier s
JOIN SP sp ON s.S# = sp.S#
JOIN Parts p ON sp.P# = p.P#
WHERE p.color = 'RED'
AND s.city = 'Surat';

-- 3) Sort the Supplier table by sname
SELECT * FROM Supplier
ORDER BY sname;

-- 4) List suppliers who supply parts to more than one city
SELECT s.S#, s.sname
FROM Supplier s
JOIN SP sp ON s.S# = sp.S#
JOIN Parts p ON sp.P# = p.P#
GROUP BY s.S#, s.sname
HAVING COUNT(DISTINCT p.city) > 1;

———————————————————————————————————————————————————————————————————————————

A) Find the sum of a user-inserted number's first and last digits using PL/pgSQL function.
B) Find out Armstrong Number from 1 to 10000 using PL/pgSQL

-- A) Find the sum of a user-inserted number's first and last digits
CREATE OR REPLACE FUNCTION sum_first_last_digits(input_number INT)
RETURNS INT
LANGUAGE plpgsql
AS $$
DECLARE
    first_digit INT;
    last_digit INT;
    number INT;
BEGIN
    -- Get the last digit
    last_digit := input_number % 10;

    -- Get the first digit by removing digits until one digit remains
    number := input_number;
    WHILE number >= 10 LOOP
        number := number / 10;
    END LOOP;
    first_digit := number;

    -- Return the sum of the first and last digits
    RETURN first_digit + last_digit;
END;
$$;

-- B) Find Armstrong numbers from 1 to 10000
CREATE OR REPLACE FUNCTION find_armstrong_numbers()
RETURNS TABLE (armstrong_number INT)
LANGUAGE plpgsql
AS $$
DECLARE
    num INT;
    digit_count INT;
    temp INT;
    sum_of_powers INT;
BEGIN
    -- Loop through numbers from 1 to 10000
    FOR num IN 1..10000 LOOP
        -- Count the number of digits in the number
        digit_count := LENGTH(num::TEXT);
        temp := num;
        sum_of_powers := 0;

        -- Calculate the sum of each digit raised to the power of digit_count
        WHILE temp > 0 LOOP
            sum_of_powers := sum_of_powers + POWER(temp % 10, digit_count);
            temp := temp / 10;
        END LOOP;

        -- Check if the number is an Armstrong number
        IF sum_of_powers = num THEN
            RETURN NEXT num;
        END IF;
    END LOOP;
END;
$$;

-- Example usage:

-- Call the function to find the sum of first and last digits
-- SELECT sum_first_last_digits(12345);

-- Call the function to find Armstrong numbers
-- SELECT * FROM find_armstrong_numbers();

———————————————————————————————————————————————————————————————————————————

Write a PL/pgSQL block using explicit cursor considering following Schemas and perform the given task. Add 10 rows in a data
set.
Consider the following schema
employee (eid, ename, did), dep (did, dname, dmanager)
Display the department name, name of the manager, number of employees in each department.

-- Create the tables
CREATE TABLE dep (
    did INT PRIMARY KEY,
    dname VARCHAR(100),
    dmanager VARCHAR(100)
);

CREATE TABLE employee (
    eid INT PRIMARY KEY,
    ename VARCHAR(100),
    did INT,
    FOREIGN KEY (did) REFERENCES dep(did)
);

-- Insert sample data
INSERT INTO dep (did, dname, dmanager) VALUES
(1, 'HR', 'Alice Johnson'),
(2, 'Finance', 'Bob Smith'),
(3, 'IT', 'Carol White'),
(4, 'Marketing', 'David Brown'),
(5, 'Sales', 'Eva Green');

INSERT INTO employee (eid, ename, did) VALUES
(1, 'John Doe', 1),
(2, 'Jane Roe', 1),
(3, 'Emily Davis', 2),
(4, 'Michael Clark', 2),
(5, 'Sarah Wilson', 3),
(6, 'Daniel Harris', 3),
(7, 'Sophia Lewis', 4),
(8, 'James Walker', 4),
(9, 'Olivia Scott', 5),
(10, 'Liam Turner', 5);

-- PL/pgSQL block using explicit cursor
DO $$
DECLARE
    emp_cursor CURSOR FOR
        SELECT d.dname, d.dmanager, COUNT(e.eid) AS num_employees
        FROM dep d
        LEFT JOIN employee e ON d.did = e.did
        GROUP BY d.dname, d.dmanager;

    rec RECORD;
BEGIN
    OPEN emp_cursor;
    LOOP
        FETCH emp_cursor INTO rec;
        EXIT WHEN NOT FOUND;

        RAISE NOTICE 'Department: %, Manager: %, Number of Employees: %',
            rec.dname, rec.dmanager, rec.num_employees;
    END LOOP;
    CLOSE emp_cursor;
END;
$$;

———————————————————————————————————————————————————————————————————————————

A) Write PL/pgSQL function that will reverse the given number and return it.
B) Write PL/pgSQL program to find the sum of digits of a number.

-- A) PL/pgSQL Function to Reverse a Given Number
CREATE OR REPLACE FUNCTION reverse_number(input_number INT)
RETURNS INT
LANGUAGE plpgsql
AS $$
DECLARE
    reversed INT := 0;
    digit INT;
    temp INT := input_number;
BEGIN
    -- Loop through the digits of the number
    WHILE temp > 0 LOOP
        -- Extract the last digit
        digit := temp % 10;
        -- Add it to the reversed number
        reversed := reversed * 10 + digit;
        -- Remove the last digit from the original number
        temp := temp / 10;
    END LOOP;

    -- Return the reversed number
    RETURN reversed;
END;
$$;

-- B) PL/pgSQL Program to Find the Sum of Digits of a Number
CREATE OR REPLACE FUNCTION sum_of_digits(input_number INT)
RETURNS INT
LANGUAGE plpgsql
AS $$
DECLARE
    sum INT := 0;
    digit INT;
    temp INT := input_number;
BEGIN
    -- Loop through the digits of the number
    WHILE temp > 0 LOOP
        -- Extract the last digit
        digit := temp % 10;
        -- Add it to the sum
        sum := sum + digit;
        -- Remove the last digit from the original number
        temp := temp / 10;
    END LOOP;

    -- Return the sum of digits
    RETURN sum;
END;
$$;

-- Example Usage:

-- Call the function to reverse a number
-- SELECT reverse_number(12345);  -- Example input

-- Call the function to find the sum of digits
-- SELECT sum_of_digits(12345);  -- Example input

———————————————————————————————————————————————————————————————————————————

The following tables form part of a database held in a relational DBMS:
Hotel (HotelNo, Name, City) Room (RoomNo, HotelNo, Type, Price) Booking (HotelNo, GuestNo, DateFrom, DateTo,
RoomNo) Guest (GuestNo, GuestName, GuestAddress)
Create tables with Primary Key, foreign key constraints in given schemas.
Solve following queries by SQL
1. List the price and type of all rooms at the Grosvenor Hotel.
2. List all guests currently staying at the Grosvenor Hotel.
3. How many guests have made bookings for August, 2023?
4. What is the total income from bookings for the Grosvenor Hotel ?
5. Update the price of all rooms by 5%.

-- Create the tables with primary and foreign key constraints

-- Create Hotel table
CREATE TABLE Hotel (
    HotelNo INT PRIMARY KEY,
    Name VARCHAR(100),
    City VARCHAR(100)
);

-- Create Room table
CREATE TABLE Room (
    RoomNo INT,
    HotelNo INT,
    Type VARCHAR(50),
    Price DECIMAL(10, 2),
    PRIMARY KEY (RoomNo, HotelNo),
    FOREIGN KEY (HotelNo) REFERENCES Hotel(HotelNo)
);

-- Create Booking table
CREATE TABLE Booking (
    HotelNo INT,
    GuestNo INT,
    DateFrom DATE,
    DateTo DATE,
    RoomNo INT,
    PRIMARY KEY (HotelNo, GuestNo, RoomNo, DateFrom),
    FOREIGN KEY (HotelNo, RoomNo) REFERENCES Room(HotelNo, RoomNo),
    FOREIGN KEY (GuestNo) REFERENCES Guest(GuestNo)
);

-- Create Guest table
CREATE TABLE Guest (
    GuestNo INT PRIMARY KEY,
    GuestName VARCHAR(100),
    GuestAddress VARCHAR(255)
);

-- Queries

-- 1. List the price and type of all rooms at the Grosvenor Hotel
SELECT r.Price, r.Type
FROM Room r
JOIN Hotel h ON r.HotelNo = h.HotelNo
WHERE h.Name = 'Grosvenor Hotel';

-- 2. List all guests currently staying at the Grosvenor Hotel
SELECT g.GuestName, g.GuestAddress
FROM Guest g
JOIN Booking b ON g.GuestNo = b.GuestNo
JOIN Hotel h ON b.HotelNo = h.HotelNo
WHERE h.Name = 'Grosvenor Hotel'
AND CURRENT_DATE BETWEEN b.DateFrom AND b.DateTo;

-- 3. How many guests have made bookings for August, 2023
SELECT COUNT(DISTINCT b.GuestNo) AS NumberOfGuests
FROM Booking b
WHERE EXTRACT(MONTH FROM b.DateFrom) = 8
AND EXTRACT(YEAR FROM b.DateFrom) = 2023;

-- 4. What is the total income from bookings for the Grosvenor Hotel
SELECT SUM(r.Price * (EXTRACT(DAY FROM b.DateTo) - EXTRACT(DAY FROM b.DateFrom) + 1)) AS TotalIncome
FROM Booking b
JOIN Room r ON b.HotelNo = r.HotelNo AND b.RoomNo = r.RoomNo
JOIN Hotel h ON b.HotelNo = h.HotelNo
WHERE h.Name = 'Grosvenor Hotel';

-- 5. Update the price of all rooms by 5%
UPDATE Room
SET Price = Price * 1.05;

———————————————————————————————————————————————————————————————————————————

Write PL/pgSQL block for an organization that has decided to increase the salary of employees by 10% of existing salary, who
are having salary less than average salary of organization.
Schema: Employee (emp_id, emp_name, salary, incremented_salary).

-- Create Employee table
CREATE TABLE Employee (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(100),
    salary NUMERIC(10, 2),
    incremented_salary NUMERIC(10, 2)
);

-- PL/pgSQL block to update salaries
DO $$
DECLARE
    avg_salary NUMERIC;
BEGIN
    -- Calculate the average salary of the organization
    SELECT AVG(salary) INTO avg_salary
    FROM Employee;

    -- Update the incremented_salary of employees with salary less than the average salary
    UPDATE Employee
    SET incremented_salary = salary * 1.10
    WHERE salary < avg_salary;

    -- Optionally, update the original salary field as well
    -- UPDATE Employee
    -- SET salary = salary * 1.10
    -- WHERE salary < avg_salary;
END;
$$;

———————————————————————————————————————————————————————————————————————————

You are responsible for maintaining a database for a shipping company.Write a PL/pgSQL Stored Procedure to insert data in
status_logs.Let name of Procedure be ‘update_shipment_status’
Consider relation: status_logs(shipment_id, new_status, update_time)
Insert below data with the help of Procedure you created shipment_id=123, new_status=delivered, update_time=2023-09-15
10:30:00.

-- Create status_logs table
CREATE TABLE status_logs (
    shipment_id INT,
    new_status VARCHAR(50),
    update_time TIMESTAMP,
    PRIMARY KEY (shipment_id, update_time)
);

-- Create PL/pgSQL Stored Procedure
CREATE OR REPLACE PROCEDURE update_shipment_status(
    p_shipment_id INT,
    p_new_status VARCHAR,
    p_update_time TIMESTAMP
)
LANGUAGE plpgsql
AS $$
BEGIN
    INSERT INTO status_logs (shipment_id, new_status, update_time)
    VALUES (p_shipment_id, p_new_status, p_update_time);
END;
$$;

-- Call the stored procedure to insert data
CALL update_shipment_status(123, 'delivered', '2023-09-15 10:30:00');

———————————————————————————————————————————————————————————————————————————

Write a SQL query considering below schema. Create tables with Primary Key, foreign key constraints in given schemas.
Manager (mid, eid, mname)
Department (did, mid, dname, location)
Employee (eid, ename, mobile, salary, joining_date, mid)
i.Give the name and salary of employees whose salary are greater than each and every employees who are working under manager
id 14.
ii.Give the name of employees who have not assigned any department.
iii.Give the employee names whose location is Kota.
iv.Give the name of manager along with count of employees assigned to him/her in descending order.

-- Create Manager table
CREATE TABLE Manager (
    mid INT PRIMARY KEY,
    eid INT,
    mname VARCHAR(100),
    FOREIGN KEY (eid) REFERENCES Employee(eid)
);

-- Create Department table
CREATE TABLE Department (
    did INT PRIMARY KEY,
    mid INT,
    dname VARCHAR(100),
    location VARCHAR(100),
    FOREIGN KEY (mid) REFERENCES Manager(mid)
);

-- Create Employee table
CREATE TABLE Employee (
    eid INT PRIMARY KEY,
    ename VARCHAR(100),
    mobile VARCHAR(15),
    salary DECIMAL(10, 2),
    joining_date DATE,
    mid INT,
    FOREIGN KEY (mid) REFERENCES Manager(mid)
);

-- Query 1: Give the name and salary of employees whose salary is greater than each and every employee who is working under manager id 14
SELECT e1.ename, e1.salary
FROM Employee e1
WHERE e1.salary > ALL (
    SELECT e2.salary
    FROM Employee e2
    WHERE e2.mid = 14
);

-- Query 2: Give the name of employees who have not been assigned any department
SELECT e.ename
FROM Employee e
LEFT JOIN Department d ON e.mid = d.mid
WHERE d.mid IS NULL;

-- Query 3: Give the employee names whose location is Kota
SELECT e.ename
FROM Employee e
JOIN Department d ON e.mid = d.mid
WHERE d.location = 'Kota';

-- Query 4: Give the name of manager along with the count of employees assigned to him/her in descending order
SELECT m.mname, COUNT(e.eid) AS employee_count
FROM Manager m
LEFT JOIN Employee e ON m.mid = e.mid
GROUP BY m.mid, m.mname
ORDER BY employee_count DESC;

———————————————————————————————————————————————————————————————————————————

Write PL/pgSQL using trigger for insertion of first_name, last_name, amount and payment_id into Customer_backup table when
deletion happens from Customer table considering below schema.
Customer_backup (first_name, last_name, amount, payment_id)
Customer (customer_id, payment_id, first_name, last_name, amount)
Create tables with Primary Key, foreign key constraints in given schemas.

-- Create Customer table
CREATE TABLE Customer (
    customer_id INT PRIMARY KEY,
    payment_id INT,
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    amount DECIMAL(10, 2),
    FOREIGN KEY (payment_id) REFERENCES Payment(payment_id) -- Assuming there's a Payment table with payment_id
);

-- Create Customer_backup table
CREATE TABLE Customer_backup (
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    amount DECIMAL(10, 2),
    payment_id INT
);

-- Create PL/pgSQL Trigger Function
CREATE OR REPLACE FUNCTION backup_customer_on_delete()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO Customer_backup (first_name, last_name, amount, payment_id)
    VALUES (OLD.first_name, OLD.last_name, OLD.amount, OLD.payment_id);
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

-- Create Trigger
CREATE TRIGGER after_customer_delete
AFTER DELETE ON Customer
FOR EACH ROW
EXECUTE FUNCTION backup_customer_on_delete();

———————————————————————————————————————————————————————————————————————————

Consider an art gallery having a database with four tables paintings, artists, Customer, and sales as:
Paintings (p_id, name, a_id, listed_price)
Artists (a_id, first_name, last_name)
Customer (c_id, first_name, last_name)
Sales (s_id, date, p_id, a_id, c_id, sales_price).
Create tables with Primary Key, foreign key constraints in given schemas.
Write queries to retrieve the following data.
1) Find the paintings that were sold in first thirteen days of month August,2023.
2) Display painting name and its listed price with its sales_price which was sold out at a price higher than the listed price to any
customer.
3) Retrieve details of paintings that were sold at a price equal to the listed price to all customers.
4) Display the name of customers who has bought at least one painting.
5) Find the total sales value for each artist.

-- Create Artists table
CREATE TABLE Artists (
    a_id INT PRIMARY KEY,
    first_name VARCHAR(100),
    last_name VARCHAR(100)
);

-- Create Paintings table
CREATE TABLE Paintings (
    p_id INT PRIMARY KEY,
    name VARCHAR(100),
    a_id INT,
    listed_price DECIMAL(10, 2),
    FOREIGN KEY (a_id) REFERENCES Artists(a_id)
);

-- Create Customer table
CREATE TABLE Customer (
    c_id INT PRIMARY KEY,
    first_name VARCHAR(100),
    last_name VARCHAR(100)
);

-- Create Sales table
CREATE TABLE Sales (
    s_id INT PRIMARY KEY,
    date DATE,
    p_id INT,
    a_id INT,
    c_id INT,
    sales_price DECIMAL(10, 2),
    FOREIGN KEY (p_id) REFERENCES Paintings(p_id),
    FOREIGN KEY (a_id) REFERENCES Artists(a_id),
    FOREIGN KEY (c_id) REFERENCES Customer(c_id)
);

-- Query 1: Find the paintings that were sold in the first thirteen days of August 2023
SELECT DISTINCT p.name
FROM Paintings p
JOIN Sales s ON p.p_id = s.p_id
WHERE s.date BETWEEN '2023-08-01' AND '2023-08-13';

-- Query 2: Display painting name and its listed price with its sales_price which was sold out at a price higher than the listed price to any customer
SELECT p.name, p.listed_price, s.sales_price
FROM Paintings p
JOIN Sales s ON p.p_id = s.p_id
WHERE s.sales_price > p.listed_price;

-- Query 3: Retrieve details of paintings that were sold at a price equal to the listed price to all customers
SELECT p.*
FROM Paintings p
JOIN Sales s ON p.p_id = s.p_id
GROUP BY p.p_id, p.name, p.a_id, p.listed_price
HAVING MIN(s.sales_price) = p.listed_price
   AND MAX(s.sales_price) = p.listed_price;

-- Query 4: Display the name of customers who have bought at least one painting
SELECT DISTINCT c.first_name, c.last_name
FROM Customer c
JOIN Sales s ON c.c_id = s.c_id;

-- Query 5: Find the total sales value for each artist
SELECT a.first_name, a.last_name, SUM(s.sales_price) AS total_sales
FROM Artists a
JOIN Paintings p ON a.a_id = p.a_id
JOIN Sales s ON p.p_id = s.p_id
GROUP BY a.a_id, a.first_name, a.last_name;

———————————————————————————————————————————————————————————————————————————

Using the following schema, write SQL statement to fetch the correct data.
Insurance_Company (c_id, c_name, city, state, policy_no, policy_name, premium, cust_id, a_id)
Agent (a_id, a_name, address, a_city, a_state, c_name, salary, incentive)
Customer (cust_id, name, age, cust_address, cust_city, cust_state, a_id, policy_no)
Create tables with Primary Key, foreign key constraints in given schemas.
1) Display the details of customer who have taken policy from ‘Ahmedabad Insurance Company’.
2) Display agent name who have not sold even a single policy.
3) Display the name of Insurance company who has maximum number of customers.

-- Create Insurance_Company table
CREATE TABLE Insurance_Company (
    c_id INT PRIMARY KEY,
    c_name VARCHAR(100),
    city VARCHAR(100),
    state VARCHAR(100),
    policy_no INT,
    policy_name VARCHAR(100),
    premium DECIMAL(10, 2),
    cust_id INT,
    a_id INT,
    FOREIGN KEY (a_id) REFERENCES Agent(a_id),
    FOREIGN KEY (policy_no) REFERENCES Customer(policy_no)
);

-- Create Agent table
CREATE TABLE Agent (
    a_id INT PRIMARY KEY,
    a_name VARCHAR(100),
    address VARCHAR(255),
    a_city VARCHAR(100),
    a_state VARCHAR(100),
    c_name VARCHAR(100),
    salary DECIMAL(10, 2),
    incentive DECIMAL(10, 2)
);

-- Create Customer table
CREATE TABLE Customer (
    cust_id INT PRIMARY KEY,
    name VARCHAR(100),
    age INT,
    cust_address VARCHAR(255),
    cust_city VARCHAR(100),
    cust_state VARCHAR(100),
    a_id INT,
    policy_no INT,
    FOREIGN KEY (a_id) REFERENCES Agent(a_id),
    FOREIGN KEY (policy_no) REFERENCES Insurance_Company(policy_no)
);

-- Query 1: Display the details of customers who have taken a policy from ‘Ahmedabad Insurance Company’
SELECT c.*
FROM Customer c
JOIN Insurance_Company ic ON c.policy_no = ic.policy_no
WHERE ic.c_name = 'Ahmedabad Insurance Company';

-- Query 2: Display agent names who have not sold even a single policy
SELECT a.a_name
FROM Agent a
LEFT JOIN Customer c ON a.a_id = c.a_id
WHERE c.a_id IS NULL;

-- Query 3: Display the name of the Insurance company with the maximum number of customers
SELECT ic.c_name
FROM Insurance_Company ic
JOIN Customer c ON ic.policy_no = c.policy_no
GROUP BY ic.c_name
ORDER BY COUNT(c.cust_id) DESC
LIMIT 1;

———————————————————————————————————————————————————————————————————————————

Consider following schema and write SQL statements for given queries using subqueries.
Faculty (f_id, f_name, address, city, state, age, salary, d_id)
Department (dep_id, d_name, course, location, sub_code, subject)
Student (enrl_no, s_name, s_address, s_city, s_state, s_age, course, f_id, hobby)
Create tables with Primary Key, foreign key constraints in given schemas.
1) Display name of faculties and students who are not living in the same city.
2) Find out how much amount is spent on faculties as their salary who are working in 'IT Engineering' Department.
3) Display department name, course, subject code and subject of person who have enrolled as a student.
4) Display id and name of faculty who are working in 'IT Engineering' department and have a salary more than Rs. 60000.

-- Create Faculty table
CREATE TABLE Faculty (
    f_id INT PRIMARY KEY,
    f_name VARCHAR(100),
    address VARCHAR(255),
    city VARCHAR(100),
    state VARCHAR(100),
    age INT,
    salary DECIMAL(10, 2),
    d_id INT,
    FOREIGN KEY (d_id) REFERENCES Department(dep_id)
);

-- Create Department table
CREATE TABLE Department (
    dep_id INT PRIMARY KEY,
    d_name VARCHAR(100),
    course VARCHAR(100),
    location VARCHAR(100),
    sub_code VARCHAR(50),
    subject VARCHAR(100)
);

-- Create Student table
CREATE TABLE Student (
    enrl_no INT PRIMARY KEY,
    s_name VARCHAR(100),
    s_address VARCHAR(255),
    s_city VARCHAR(100),
    s_state VARCHAR(100),
    s_age INT,
    course VARCHAR(100),
    f_id INT,
    hobby VARCHAR(100),
    FOREIGN KEY (f_id) REFERENCES Faculty(f_id)
);

-- Query 1: Display name of faculties and students who are not living in the same city
SELECT f.f_name AS name
FROM Faculty f
WHERE f.city NOT IN (SELECT s.s_city FROM Student s WHERE s.f_id = f.f_id)
UNION
SELECT s.s_name AS name
FROM Student s
WHERE s.s_city NOT IN (SELECT f.city FROM Faculty f WHERE f.f_id = s.f_id);

-- Query 2: Find out how much amount is spent on faculties as their salary who are working in 'IT Engineering' Department
SELECT SUM(f.salary) AS total_salary
FROM Faculty f
WHERE f.d_id = (SELECT d.dep_id FROM Department d WHERE d.d_name = 'IT Engineering');

-- Query 3: Display department name, course, subject code and subject of person who have enrolled as a student
SELECT d.d_name, d.course, d.sub_code, d.subject
FROM Department d
JOIN Student s ON s.course = d.course
WHERE s.f_id IS NOT NULL;

-- Query 4: Display id and name of faculty who are working in 'IT Engineering' department and have a salary more than Rs. 60000
SELECT f.f_id, f.f_name
FROM Faculty f
WHERE f.d_id = (SELECT d.dep_id FROM Department d WHERE d.d_name = 'IT Engineering')
AND f.salary > 60000;

———————————————————————————————————————————————————————————————————————————

Prepare a PL/pgSQL block that simulates an ATM transaction system.
•If the withdrawal amount is less than or equal to 0, the block should display an "Invalid withdrawal amount" message.
•If the withdrawal amount is greater than the account balance, the block should display an "Insufficient funds" message.
•If the withdrawal amount is up to Rs. 20000, the block should perform a withdrawal and deduct the amount from the account
balance.
•If the withdrawal amount is up to Rs. 40000, the block should perform a withdrawal, deduct the amount, and apply a transaction
fee 5%.
•For withdrawal amounts greater than Rs. 40000, the block should perform a withdrawal, deduct the amount, and apply a higher
transaction fee 18%.
The block should also display the current account balance after each scenario.

-- Create Account table
CREATE TABLE Account (
    account_id INT PRIMARY KEY,
    account_balance DECIMAL(10, 2) NOT NULL
);

-- Insert a sample record into Account table
INSERT INTO Account (account_id, account_balance) VALUES (1, 50000);

-- PL/pgSQL Block to simulate ATM transaction
DO $$
DECLARE
    v_account_id INT := 1; -- Example account ID
    v_withdrawal_amount DECIMAL(10, 2) := 35000; -- Example withdrawal amount
    v_current_balance DECIMAL(10, 2);
    v_transaction_fee DECIMAL(10, 2);
BEGIN
    -- Fetch current balance from the Account table
    SELECT account_balance INTO v_current_balance
    FROM Account
    WHERE account_id = v_account_id;

    -- Check if withdrawal amount is valid
    IF v_withdrawal_amount <= 0 THEN
        RAISE NOTICE 'Invalid withdrawal amount';
    ELSIF v_withdrawal_amount > v_current_balance THEN
        RAISE NOTICE 'Insufficient funds';
    ELSE
        -- Determine the transaction fee and adjust the balance
        IF v_withdrawal_amount <= 20000 THEN
            v_transaction_fee := 0;
        ELSIF v_withdrawal_amount <= 40000 THEN
            v_transaction_fee := v_withdrawal_amount * 0.05; -- 5% fee
        ELSE
            v_transaction_fee := v_withdrawal_amount * 0.18; -- 18% fee
        END IF;

        -- Update the account balance
        UPDATE Account
        SET account_balance = v_current_balance - v_withdrawal_amount - v_transaction_fee
        WHERE account_id = v_account_id;

        -- Display the result
        RAISE NOTICE 'Withdrawal successful. Transaction fee: %.2f', v_transaction_fee;
        RAISE NOTICE 'Current account balance: %.2f', v_current_balance - v_withdrawal_amount - v_transaction_fee;
    END IF;
END $$;

———————————————————————————————————————————————————————————————————————————

Design a database for a library management system. Each book in the library has multiple copies, and you want to implement a
feature that allows users to check the availability of a specific book by its ISBN (International Standard Book Number).
Write PL/pgSQL block using stored function. If book is available then it must return 1 else return 0.
Consider relation:Books ( books_isbn,book_name) Now what you will write to check availability of book having ISBN-
9780451524935

-- Create the Books table
CREATE TABLE Books (
    books_isbn VARCHAR(13) PRIMARY KEY,
    book_name VARCHAR(255) NOT NULL
);

-- Create the Copies table to keep track of multiple copies of each book
CREATE TABLE Copies (
    copy_id SERIAL PRIMARY KEY,
    books_isbn VARCHAR(13) REFERENCES Books(books_isbn),
    available BOOLEAN DEFAULT TRUE -- Indicates if the copy is available
);

-- Insert sample data into Books table
INSERT INTO Books (books_isbn, book_name) VALUES
('9780451524935', '1984'),
('9780132350884', 'Clean Code');

-- Insert sample data into Copies table
INSERT INTO Copies (books_isbn, available) VALUES
('9780451524935', TRUE),
('9780451524935', FALSE),
('9780132350884', TRUE),
('9780132350884', TRUE);

-- Create the function to check the availability of a book
CREATE OR REPLACE FUNCTION check_book_availability(p_isbn VARCHAR)
RETURNS INTEGER AS $$
DECLARE
    v_count INTEGER;
BEGIN
    -- Count the number of available copies for the given ISBN
    SELECT COUNT(*)
    INTO v_count
    FROM Copies
    WHERE books_isbn = p_isbn AND available = TRUE;

    -- Return 1 if at least one copy is available, otherwise return 0
    IF v_count > 0 THEN
        RETURN 1;
    ELSE
        RETURN 0;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- Example Usage: Check availability of the book with ISBN '9780451524935'
SELECT check_book_availability('9780451524935') AS availability;

———————————————————————————————————————————————————————————————————————————

In PostgreSQL, create a PL/pgSQL block that defines a function named calculate_salary_bonus which takes two parameters:
employee_id and bonus_percentage. This function should calculate the bonus amount for the employee with the given
employee_id based on their current salary and the provided bonus percentage. Assume “employee” table with fields – eid, ename
and salary.

-- Create the employee table
CREATE TABLE employee (
    eid SERIAL PRIMARY KEY,
    ename VARCHAR(100),
    salary NUMERIC(10, 2)
);

-- Insert sample data into employee table
INSERT INTO employee (ename, salary) VALUES
('John Doe', 50000.00),
('Jane Smith', 60000.00),
('Emily Johnson', 55000.00);

-- Create the function to calculate the salary bonus
CREATE OR REPLACE FUNCTION calculate_salary_bonus(
    p_employee_id INTEGER,
    p_bonus_percentage NUMERIC
)
RETURNS NUMERIC AS $$
DECLARE
    v_salary NUMERIC;
    v_bonus NUMERIC;
BEGIN
    -- Retrieve the salary for the given employee_id
    SELECT salary
    INTO v_salary
    FROM employee
    WHERE eid = p_employee_id;

    -- Check if the employee exists
    IF v_salary IS NULL THEN
        RAISE EXCEPTION 'Employee with ID % does not exist.', p_employee_id;
    END IF;

    -- Calculate the bonus amount
    v_bonus := v_salary * (p_bonus_percentage / 100);

    -- Return the bonus amount
    RETURN v_bonus;
END;
$$ LANGUAGE plpgsql;

-- Example usage of the function
-- Calculate the bonus for employee with ID 1 with a bonus percentage of 10%
SELECT calculate_salary_bonus(1, 10) AS bonus_amount;

———————————————————————————————————————————————————————————————————————————

An expression below creates a procedure emp_infor that accept two parameters: employeeno and job_title, then pass them to
explicit cursor named emp_list to retrieve the firstname, lastname, hiredate, job_id and salary, of all employees earning a salary
less that 11000 and have an “O” as the second letter in the lastname. Create an anonymous block that will call the procedure to
display the details of employee as per entry of job_title and employeeno parameters. Use this table Employee (employeeno,
firstname, lastname, hiredate, job_id ,salary, job_title).

-- Create the Employee table
CREATE TABLE Employee (
    employeeno INTEGER PRIMARY KEY,
    firstname VARCHAR(50),
    lastname VARCHAR(50),
    hiredate DATE,
    job_id VARCHAR(10),
    salary NUMERIC(10, 2),
    job_title VARCHAR(50)
);

-- Insert sample data into Employee table
INSERT INTO Employee (employeeno, firstname, lastname, hiredate, job_id, salary, job_title) VALUES
(1, 'John', 'Doe', '2023-01-15', 'IT_PROG', 9000, 'Programmer'),
(2, 'Jane', 'Oconnor', '2022-03-22', 'HR_REP', 8000, 'HR Representative'),
(3, 'Emily', 'Smith', '2021-05-30', 'AD_ASST', 11000, 'Administrative Assistant'),
(4, 'Michael', 'Johnson', '2024-07-10', 'IT_PROG', 9500, 'Programmer'),
(5, 'Sarah', 'Olsen', '2022-11-05', 'IT_PROG', 10000, 'Programmer');

-- Create the procedure to retrieve employee information
CREATE OR REPLACE PROCEDURE emp_infor(
    p_employeeno INTEGER,
    p_job_title VARCHAR
)
LANGUAGE plpgsql
AS $$
DECLARE
    -- Define an explicit cursor to retrieve the employee details
    CURSOR emp_list IS
        SELECT firstname, lastname, hiredate, job_id, salary
        FROM Employee
        WHERE salary < 11000
          AND SUBSTRING(lastname FROM 2 FOR 1) = 'O'
          AND job_title = p_job_title;

    -- Define variables to hold the cursor output
    v_firstname Employee.firstname%TYPE;
    v_lastname Employee.lastname%TYPE;
    v_hiredate Employee.hiredate%TYPE;
    v_job_id Employee.job_id%TYPE;
    v_salary Employee.salary%TYPE;
BEGIN
    -- Open the cursor and fetch each row
    OPEN emp_list;
    LOOP
        FETCH emp_list INTO v_firstname, v_lastname, v_hiredate, v_job_id, v_salary;
        EXIT WHEN NOT FOUND;
        
        -- Display the details
        RAISE NOTICE 'First Name: %, Last Name: %, Hire Date: %, Job ID: %, Salary: %',
                     v_firstname, v_lastname, v_hiredate, v_job_id, v_salary;
    END LOOP;

    -- Close the cursor
    CLOSE emp_list;
END;
$$;

-- Anonymous block to call the procedure
DO $$
BEGIN
    -- Call the procedure with specific parameters
    CALL emp_infor(1, 'Programmer');
END;
$$;

———————————————————————————————————————————————————————————————————————————

Write a PL/pgSQL block to find out count of completed month between two dates enter by the user.

-- Create a table to store date ranges
CREATE TABLE DateRanges (
    id SERIAL PRIMARY KEY,
    start_date DATE,
    end_date DATE
);

-- Insert sample data into the DateRanges table
INSERT INTO DateRanges (start_date, end_date) VALUES
('2023-01-15', '2024-08-13'),
('2022-03-01', '2023-10-01'),
('2021-06-15', '2022-05-15');

-- PL/pgSQL block to calculate completed months between dates from DateRanges table
DO $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
    v_start_month DATE;
    v_end_month DATE;
    v_months_count INTEGER;
BEGIN
    -- Cursor to fetch date ranges from the DateRanges table
    FOR v_start_date, v_end_date IN
        SELECT start_date, end_date
        FROM DateRanges
    LOOP
        -- Initialize the start and end months
        v_start_month := DATE_TRUNC('month', v_start_date);
        v_end_month := DATE_TRUNC('month', v_end_date);
        
        -- Calculate the number of complete months
        IF v_end_date >= v_start_date THEN
            v_months_count := (EXTRACT(YEAR FROM v_end_date) - EXTRACT(YEAR FROM v_start_date)) * 12
                              + EXTRACT(MONTH FROM v_end_date) - EXTRACT(MONTH FROM v_start_date);
            
            -- Adjust if the end date is not in the same month as the end of the month
            IF v_end_date < (v_start_month + (v_months_count + 1) * INTERVAL '1 month') THEN
                v_months_count := v_months_count - 1;
            END IF;
            
            -- Output the result
            RAISE NOTICE 'Number of completed months between % and %: %', v_start_date, v_end_date, v_months_count;
        ELSE
            RAISE NOTICE 'The end date must be greater than or equal to the start date.';
        END IF;
    END LOOP;
END;
$$;

———————————————————————————————————————————————————————————————————————————

Writer a PL/pgSQL block to generate marksheet. Take 1st five column values and find out TOTAL_MARKS, PERCENTAGE,
GRADE using cursor. Assume suitable data
Student_Marksheet (ROLLNO, SNAME, DIV, DBMS, DS, TOTAL_MARKS, PERCENTAGE, GRADE)

-- Create the Student_Marksheet table
CREATE TABLE Student_Marksheet (
    ROLLNO INT PRIMARY KEY,
    SNAME VARCHAR(100),
    DIV VARCHAR(10),
    DBMS INT,
    DS INT,
    TOTAL_MARKS INT,
    PERCENTAGE NUMERIC(5, 2),
    GRADE CHAR(1)
);

-- Insert sample data
INSERT INTO Student_Marksheet (ROLLNO, SNAME, DIV, DBMS, DS) VALUES
(101, 'Alice', 'A', 85, 90),
(102, 'Bob', 'B', 78, 82),
(103, 'Charlie', 'A', 92, 88),
(104, 'David', 'C', 70, 75);

-- PL/pgSQL block to generate marksheet
DO $$
DECLARE
    -- Declare variables
    v_rollno INT;
    v_sname VARCHAR(100);
    v_div VARCHAR(10);
    v_dbms INT;
    v_ds INT;
    v_total_marks INT;
    v_percentage NUMERIC(5, 2);
    v_grade CHAR(1);
    
    -- Define a cursor to fetch student marks data
    CURSOR student_cursor IS
        SELECT ROLLNO, SNAME, DIV, DBMS, DS
        FROM Student_Marksheet;
BEGIN
    -- Loop through the cursor
    FOR student_record IN student_cursor LOOP
        -- Assign values from the cursor to variables
        v_rollno := student_record.ROLLNO;
        v_sname := student_record.SNAME;
        v_div := student_record.DIV;
        v_dbms := student_record.DBMS;
        v_ds := student_record.DS;
        
        -- Calculate TOTAL_MARKS, PERCENTAGE, and GRADE
        v_total_marks := v_dbms + v_ds;
        v_percentage := (v_total_marks * 100.0) / 200;  -- Assuming total marks for DBMS and DS are 100 each
        
        -- Determine the GRADE based on percentage
        IF v_percentage >= 90 THEN
            v_grade := 'A';
        ELSIF v_percentage >= 80 THEN
            v_grade := 'B';
        ELSIF v_percentage >= 70 THEN
            v_grade := 'C';
        ELSIF v_percentage >= 60 THEN
            v_grade := 'D';
        ELSE
            v_grade := 'F';
        END IF;
        
        -- Update the Student_Marksheet table with calculated values
        UPDATE Student_Marksheet
        SET TOTAL_MARKS = v_total_marks,
            PERCENTAGE = v_percentage,
            GRADE = v_grade
        WHERE ROLLNO = v_rollno;
        
        -- Output the result
        RAISE NOTICE 'Roll No: %, Name: %, DIV: %, DBMS: %, DS: %, Total Marks: %, Percentage: %, Grade: %',
            v_rollno, v_sname, v_div, v_dbms, v_ds, v_total_marks, v_percentage, v_grade;
    END LOOP;
END;
$$;

———————————————————————————————————————————————————————————————————————————

Write a code in PL/pgSQL to create a trigger for following conditions
1. Create table for products ( product_id, product_name)
2. Check for duplicate entry in a product_name and raise an error before insertion of duplicate value. Also show trigger by
inserting the value.

-- 1. Create the `products` table
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    product_name VARCHAR(100) UNIQUE
);

-- 2. Define a PL/pgSQL function to check for duplicates
CREATE OR REPLACE FUNCTION check_duplicate_product() 
RETURNS TRIGGER AS $$
BEGIN
    -- Check if the product_name already exists
    IF EXISTS (SELECT 1 FROM products WHERE product_name = NEW.product_name) THEN
        -- Raise an error if a duplicate is found
        RAISE EXCEPTION 'Duplicate product_name: %', NEW.product_name;
    END IF;
    
    -- If no duplicate is found, proceed with the insertion
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 3. Create a trigger that uses the above function
CREATE TRIGGER trg_check_duplicate
BEFORE INSERT ON products
FOR EACH ROW
EXECUTE FUNCTION check_duplicate_product();

-- 4. Insert values to demonstrate how the trigger works
-- This should work fine
INSERT INTO products (product_name) VALUES ('Laptop');

-- This will raise an error because 'Laptop' already exists
INSERT INTO products (product_name) VALUES ('Laptop');

———————————————————————————————————————————————————————————————————————————

Write trigger in PL/pgSQL for a library book management system. This includes:
Schema creation:
Books (bid, btitle,book_count), Book_issue (id, sid, btitle)
Create tables with Primary Key, foreign key constraints in given schemas.
Create relevant database and if any student borrows a book from library then the count of that specified book should be
decremented.

-- 1. Create the Books and Book_issue tables with Primary Key and Foreign Key constraints
CREATE TABLE Books (
    bid SERIAL PRIMARY KEY,
    btitle VARCHAR(255) UNIQUE NOT NULL,
    book_count INT NOT NULL CHECK (book_count >= 0)
);

CREATE TABLE Book_issue (
    id SERIAL PRIMARY KEY,
    sid INT NOT NULL, -- Assuming sid is a student ID; it's not a foreign key in this example
    btitle VARCHAR(255) NOT NULL,
    FOREIGN KEY (btitle) REFERENCES Books (btitle)
);

-- 2. Define the PL/pgSQL function to decrement the book count
CREATE OR REPLACE FUNCTION decrement_book_count() 
RETURNS TRIGGER AS $$
BEGIN
    -- Decrement the book count for the issued book
    UPDATE Books
    SET book_count = book_count - 1
    WHERE btitle = NEW.btitle;

    -- Check if the book count is negative after update
    IF (SELECT book_count FROM Books WHERE btitle = NEW.btitle) < 0 THEN
        RAISE EXCEPTION 'Not enough copies available for book: %', NEW.btitle;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 3. Create the trigger to use the function
CREATE TRIGGER trg_decrement_book_count
AFTER INSERT ON Book_issue
FOR EACH ROW
EXECUTE FUNCTION decrement_book_count();

-- 4. Insert sample data to test the trigger
-- Insert sample data into Books
INSERT INTO Books (btitle, book_count) VALUES ('The Great Gatsby', 5);
INSERT INTO Books (btitle, book_count) VALUES ('1984', 3);

-- Insert data into Book_issue to test the trigger
-- This should decrement the count of 'The Great Gatsby' by 1
INSERT INTO Book_issue (sid, btitle) VALUES (1, 'The Great Gatsby');

-- This should decrement the count of '1984' by 1
INSERT INTO Book_issue (sid, btitle) VALUES (2, '1984');

-- Try to insert more issues than available
-- This should raise an exception if book_count goes negative
INSERT INTO Book_issue (sid, btitle) VALUES (3, '1984');

———————————————————————————————————————————————————————————————————————————

Write a PL/pgSQL Trigger program that logs the detail of each new order, including the product associated information , into a
order_logs table whenever a new order is inserted into order table. Create tables with Primary Key, foreign key constraints in
given schemas.
Products(product_id, product_name, price) ,
Orders(order_id, product_id, quantity),
Order_logs(log_id, product_id, product_name, price, quantity, order_date)

-- 1. Create the tables with Primary Key and Foreign Key constraints

-- Table to store product details
CREATE TABLE Products (
    product_id SERIAL PRIMARY KEY,
    product_name VARCHAR(255) NOT NULL,
    price NUMERIC(10, 2) NOT NULL
);

-- Table to store orders
CREATE TABLE Orders (
    order_id SERIAL PRIMARY KEY,
    product_id INT NOT NULL,
    quantity INT NOT NULL CHECK (quantity > 0),
    FOREIGN KEY (product_id) REFERENCES Products (product_id)
);

-- Table to log order details
CREATE TABLE Order_logs (
    log_id SERIAL PRIMARY KEY,
    product_id INT NOT NULL,
    product_name VARCHAR(255) NOT NULL,
    price NUMERIC(10, 2) NOT NULL,
    quantity INT NOT NULL,
    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (product_id) REFERENCES Products (product_id)
);

-- 2. Define the PL/pgSQL function for logging orders
CREATE OR REPLACE FUNCTION log_order_details()
RETURNS TRIGGER AS $$
BEGIN
    -- Insert a log entry into Order_logs
    INSERT INTO Order_logs (product_id, product_name, price, quantity, order_date)
    SELECT 
        NEW.product_id,
        p.product_name,
        p.price,
        NEW.quantity,
        CURRENT_TIMESTAMP
    FROM Products p
    WHERE p.product_id = NEW.product_id;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 3. Create the trigger to use the function
CREATE TRIGGER trg_log_order_details
AFTER INSERT ON Orders
FOR EACH ROW
EXECUTE FUNCTION log_order_details();

-- 4. Insert sample data to test the trigger
-- Insert sample products
INSERT INTO Products (product_name, price) VALUES ('Laptop', 1200.00);
INSERT INTO Products (product_name, price) VALUES ('Smartphone', 700.00);

-- Insert a new order to test the trigger
-- This should log details into Order_logs
INSERT INTO Orders (product_id, quantity) VALUES (1, 2);  -- Assume product_id 1 is 'Laptop'

-- Check Order_logs table to verify that the log entry has been created
SELECT * FROM Order_logs;

———————————————————————————————————————————————————————————————————————————

You are tasked with creating a trigger in PL/pgSQL to monitor updates to employee salaries in a table named Employees. The
Employees table has the following columns: EmployeeID, Name, and Salary.
Write an AFTER UPDATE trigger that:
Fires after an UPDATE operation on the Salary column.
Calculate and display the old salary, the new salary, and the difference between the two for each updated record.

-- 1. Create the Employees table
CREATE TABLE Employees (
    EmployeeID SERIAL PRIMARY KEY,
    Name VARCHAR(100) NOT NULL,
    Salary NUMERIC(10, 2) NOT NULL
);

-- 2. Define the PL/pgSQL function for the trigger
CREATE OR REPLACE FUNCTION log_salary_update()
RETURNS TRIGGER AS $$
BEGIN
    -- Display the old salary, new salary, and difference
    RAISE NOTICE 'EmployeeID: %, Name: %, Old Salary: %, New Salary: %, Difference: %',
                 OLD.EmployeeID,
                 OLD.Name,
                 OLD.Salary,
                 NEW.Salary,
                 (NEW.Salary - OLD.Salary);
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 3. Create the trigger to use the function
CREATE TRIGGER trg_salary_update
AFTER UPDATE OF Salary
ON Employees
FOR EACH ROW
EXECUTE FUNCTION log_salary_update();

-- 4. Test the trigger
-- Insert sample data
INSERT INTO Employees (Name, Salary) VALUES ('John Doe', 50000);
INSERT INTO Employees (Name, Salary) VALUES ('Jane Smith', 60000);

-- Update salaries to trigger the log
UPDATE Employees SET Salary = 55000 WHERE Name = 'John Doe';
UPDATE Employees SET Salary = 65000 WHERE Name = 'Jane Smith';

-- The trigger should display messages showing old and new salaries with the difference

———————————————————————————————————————————————————————————————————————————

Write a PL/pgSQL function that converts temperatures between Fahrenheit, Celsius and Kelvin.
The function should take three parameters:
1. The temperature value to convert.
2. The scale of the input temperature.
3. The scale to convert the temperature.
Use the following Conversion Logic:
• Fahrenheit to Celsius: C= (F−32) × 5/9
• Celsius to Fahrenheit: F=(C × 9/5) + 32
• Fahrenheit to Kelvin: K=(F − 32)×5/9+273.15
• Celsius to Kelvin: K=C+273.15
• Kelvin to Fahrenheit: F=(K−273.15)×9/5+32
• Kelvin to Celsius: C=K−273.15

CREATE OR REPLACE FUNCTION convert_temperature(
    temp_value NUMERIC,            -- The temperature value to convert
    from_scale CHAR,               -- The scale of the input temperature ('F', 'C', 'K')
    to_scale CHAR                  -- The scale to convert the temperature ('F', 'C', 'K')
)
RETURNS NUMERIC AS $$
DECLARE
    result NUMERIC;               -- Variable to hold the conversion result
BEGIN
    -- Check if the input and output scales are the same
    IF from_scale = to_scale THEN
        RETURN temp_value;
    END IF;

    -- Convert from the input scale to Kelvin
    IF from_scale = 'F' THEN
        temp_value := (temp_value - 32) * 5/9 + 273.15;  -- Fahrenheit to Kelvin
    ELSIF from_scale = 'C' THEN
        temp_value := temp_value + 273.15;               -- Celsius to Kelvin
    ELSIF from_scale = 'K' THEN
        temp_value := temp_value;                        -- Kelvin remains the same
    ELSE
        RAISE EXCEPTION 'Invalid input scale: %', from_scale;
    END IF;

    -- Convert from Kelvin to the target scale
    IF to_scale = 'F' THEN
        result := (temp_value - 273.15) * 9/5 + 32;      -- Kelvin to Fahrenheit
    ELSIF to_scale = 'C' THEN
        result := temp_value - 273.15;                   -- Kelvin to Celsius
    ELSIF to_scale = 'K' THEN
        result := temp_value;                            -- Kelvin remains the same
    ELSE
        RAISE EXCEPTION 'Invalid output scale: %', to_scale;
    END IF;

    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Example usage of the function:
-- SELECT convert_temperature(100, 'F', 'C'); -- Converts 100°F to Celsius
-- SELECT convert_temperature(0, 'C', 'K');   -- Converts 0°C to Kelvin
-- SELECT convert_temperature(273.15, 'K', 'F'); -- Converts 273.15K to Fahrenheit

———————————————————————————————————————————————————————————————————————————

Write a PL/pgSQL stored procedure that uses a cursor to fetch and print the detail of each order, including the associated product
information ordered by order_id. Create tables with Primary Key, foreign key constraints in given schemas.
Products(product_id, product_name, price), Orders(order_id, product_id, quantity).

-- Create Products table
CREATE TABLE Products (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(100),
    price NUMERIC
);

-- Create Orders table
CREATE TABLE Orders (
    order_id INT,
    product_id INT,
    quantity INT,
    PRIMARY KEY (order_id, product_id),
    FOREIGN KEY (product_id) REFERENCES Products(product_id)
);

-- Create the stored procedure
CREATE OR REPLACE PROCEDURE print_order_details()
LANGUAGE plpgsql
AS $$
DECLARE
    -- Define a cursor to fetch orders and associated product information
    CURSOR order_cursor IS
        SELECT o.order_id, p.product_name, p.price, o.quantity
        FROM Orders o
        JOIN Products p ON o.product_id = p.product_id
        ORDER BY o.order_id;

    -- Variables to hold the cursor values
    v_order_id INT;
    v_product_name VARCHAR(100);
    v_price NUMERIC;
    v_quantity INT;
BEGIN
    -- Open the cursor
    OPEN order_cursor;

    -- Loop through all rows returned by the cursor
    LOOP
        FETCH order_cursor INTO v_order_id, v_product_name, v_price, v_quantity;
        EXIT WHEN NOT FOUND;

        -- Print the details of each order
        RAISE NOTICE 'Order ID: %, Product Name: %, Price: %, Quantity: %',
            v_order_id, v_product_name, v_price, v_quantity;
    END LOOP;

    -- Close the cursor
    CLOSE order_cursor;
END;
$$;

———————————————————————————————————————————————————————————————————————————

Consider the following relational schema that manages the assignment of scholarship to students.
APPLICATION (StudentID, Date, State)
COURSE (CourseID, Title, Credits)
RANKING (StudentID, Avg_score, Credits, Rank)
EXAM (CourseID, StudentID, Date, Grade)
Create tables with Primary Key, foreign key constraints in given schemas.
We want to manage through a system of triggers the assignment of scholarship to students. The scholarship are awarded to
students who apply and, at the date of the application, have taken exams for at least 50 credits, with an average score of at least 27.

-- Create tables
CREATE TABLE APPLICATION (
    StudentID INT,
    Date DATE,
    State VARCHAR(50),
    PRIMARY KEY (StudentID, Date)
);

CREATE TABLE COURSE (
    CourseID INT PRIMARY KEY,
    Title VARCHAR(100),
    Credits INT
);

CREATE TABLE RANKING (
    StudentID INT PRIMARY KEY,
    Avg_score NUMERIC,
    Credits INT,
    Rank INT
);

CREATE TABLE EXAM (
    CourseID INT,
    StudentID INT,
    Date DATE,
    Grade CHAR(1),
    PRIMARY KEY (CourseID, StudentID, Date),
    FOREIGN KEY (CourseID) REFERENCES COURSE(CourseID),
    FOREIGN KEY (StudentID) REFERENCES RANKING(StudentID)
);

-- Create SCHOLARSHIP table to store scholarship information (assumed for demonstration)
CREATE TABLE SCHOLARSHIP (
    StudentID INT PRIMARY KEY,
    ScholarshipAwarded BOOLEAN
);

-- Create the trigger function
CREATE OR REPLACE FUNCTION assign_scholarship() 
RETURNS TRIGGER AS $$
DECLARE
    total_credits INT;
    avg_score NUMERIC;
BEGIN
    -- Calculate total credits and average score for the student
    SELECT SUM(c.Credits), r.Avg_score
    INTO total_credits, avg_score
    FROM EXAM e
    JOIN COURSE c ON e.CourseID = c.CourseID
    JOIN RANKING r ON e.StudentID = r.StudentID
    WHERE e.StudentID = NEW.StudentID
    GROUP BY r.Avg_score;

    -- Check if the student meets the criteria
    IF total_credits >= 50 AND avg_score >= 27 THEN
        -- Insert a record into the SCHOLARSHIP table if criteria are met
        INSERT INTO SCHOLARSHIP (StudentID, ScholarshipAwarded)
        VALUES (NEW.StudentID, TRUE)
        ON CONFLICT (StudentID) DO UPDATE 
        SET ScholarshipAwarded = TRUE;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create the trigger
CREATE TRIGGER trg_assign_scholarship
AFTER INSERT ON APPLICATION
FOR EACH ROW
EXECUTE FUNCTION assign_scholarship();

———————————————————————————————————————————————————————————————————————————

Write a stored procedure named update_marks that updates the marks of a student in the Result_SEM_II table. Also handle error
if Enrollment_no is not found. The procedure should take three parameters:
1. Enrollment_no 2. Subject_name 3. New_marks
Result_SEM_II (EN_NO , NAME, DBMS_MARKS, DS_MARKS, JAVA_MARKS, FEE_MARKS, MATHS_MARKS)

-- Create the Result_SEM_II table
CREATE TABLE Result_SEM_II (
    EN_NO INT PRIMARY KEY,
    NAME VARCHAR(100),
    DBMS_MARKS NUMERIC,
    DS_MARKS NUMERIC,
    JAVA_MARKS NUMERIC,
    FEE_MARKS NUMERIC,
    MATHS_MARKS NUMERIC
);

-- Create the stored procedure
CREATE OR REPLACE PROCEDURE update_marks(
    p_enrollment_no INT,
    p_subject_name VARCHAR,
    p_new_marks NUMERIC
)
LANGUAGE plpgsql
AS $$
BEGIN
    -- Check if the enrollment number exists
    IF NOT EXISTS (SELECT 1 FROM Result_SEM_II WHERE EN_NO = p_enrollment_no) THEN
        RAISE EXCEPTION 'Enrollment number % not found.', p_enrollment_no;
    END IF;

    -- Update the marks based on the subject
    CASE p_subject_name
        WHEN 'DBMS' THEN
            UPDATE Result_SEM_II
            SET DBMS_MARKS = p_new_marks
            WHERE EN_NO = p_enrollment_no;
        WHEN 'DS' THEN
            UPDATE Result_SEM_II
            SET DS_MARKS = p_new_marks
            WHERE EN_NO = p_enrollment_no;
        WHEN 'JAVA' THEN
            UPDATE Result_SEM_II
            SET JAVA_MARKS = p_new_marks
            WHERE EN_NO = p_enrollment_no;
        WHEN 'FEE' THEN
            UPDATE Result_SEM_II
            SET FEE_MARKS = p_new_marks
            WHERE EN_NO = p_enrollment_no;
        WHEN 'MATHS' THEN
            UPDATE Result_SEM_II
            SET MATHS_MARKS = p_new_marks
            WHERE EN_NO = p_enrollment_no;
        ELSE
            RAISE EXCEPTION 'Invalid subject name: %', p_subject_name;
    END CASE;

    -- Confirm successful update
    RAISE NOTICE 'Marks updated successfully for Enrollment No %.', p_enrollment_no;
END;
$$;

-- Example of calling the stored procedure
-- CALL update_marks(12345, 'JAVA', 85);

———————————————————————————————————————————————————————————————————————————

Prepare a trigger while updating the mobile number of employee and store old and new updated number into a table named
Emp_log with details of employee id, fname, old_mno, new_mno and update_time using following schemas:
Emp(id, fname, mno)
Emp_log(id, fname, old_mno, new_mno, update_time)
Create tables and also add five data in the Emp table. Also update mobile number of any employee and if updated mobile number
is same as old number, display a notice that "mobile number can not be updated" and Emp_log should not update.

-- Create the Emp table
CREATE TABLE Emp (
    id INT PRIMARY KEY,
    fname VARCHAR(100),
    mno VARCHAR(15)
);

-- Create the Emp_log table
CREATE TABLE Emp_log (
    id INT,
    fname VARCHAR(100),
    old_mno VARCHAR(15),
    new_mno VARCHAR(15),
    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (id) REFERENCES Emp(id)
);

-- Insert sample data into Emp table
INSERT INTO Emp (id, fname, mno) VALUES
(1, 'John Doe', '1234567890'),
(2, 'Jane Smith', '2345678901'),
(3, 'Emily Davis', '3456789012'),
(4, 'Michael Brown', '4567890123'),
(5, 'Sarah Wilson', '5678901234');

-- Create the trigger function
CREATE OR REPLACE FUNCTION trg_update_mno()
RETURNS TRIGGER AS $$
BEGIN
    -- Check if the new mobile number is the same as the old one
    IF NEW.mno = OLD.mno THEN
        RAISE NOTICE 'Mobile number cannot be updated as it is the same as the old number.';
        -- Prevent the update by raising an exception
        RAISE EXCEPTION 'Mobile number is the same as the old number. Update not performed.';
    END IF;

    -- Insert a log entry into Emp_log table
    INSERT INTO Emp_log (id, fname, old_mno, new_mno, update_time)
    VALUES (OLD.id, OLD.fname, OLD.mno, NEW.mno, CURRENT_TIMESTAMP);

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create the trigger
CREATE TRIGGER before_update_mno
BEFORE UPDATE OF mno
ON Emp
FOR EACH ROW
EXECUTE FUNCTION trg_update_mno();

-- Update mobile number to test trigger
-- Note: This should trigger a notice and insert a log if numbers are different
-- UPDATE Emp SET mno = '6789012345' WHERE id = 1;

-- Update mobile number to test case where new number is the same as the old number
-- This should raise a notice and prevent the update
UPDATE Emp SET mno = '1234567890' WHERE id = 1;

———————————————————————————————————————————————————————————————————————————

Write a PL/pgSQL cursor to fetch the titles of movies that were rented out in the last one month from current date.
Consider schema:
movies (movie_id,title,release_date)
rentals ( rental_id, movie_id, rental_date)

-- Create the tables
CREATE TABLE movies (
    movie_id SERIAL PRIMARY KEY,
    title VARCHAR(255),
    release_date DATE
);

CREATE TABLE rentals (
    rental_id SERIAL PRIMARY KEY,
    movie_id INT REFERENCES movies(movie_id),
    rental_date DATE
);

-- PL/pgSQL block with cursor
DO $$
DECLARE
    -- Declare cursor to fetch movie titles
    movie_cursor CURSOR FOR
        SELECT m.title
        FROM movies m
        JOIN rentals r ON m.movie_id = r.movie_id
        WHERE r.rental_date >= CURRENT_DATE - INTERVAL '1 month';
    
    -- Variable to store movie title
    movie_title movies.title%TYPE;
BEGIN
    -- Open the cursor
    OPEN movie_cursor;
    
    -- Loop through the cursor and fetch movie titles
    LOOP
        FETCH movie_cursor INTO movie_title;
        EXIT WHEN NOT FOUND;
        
        -- Display the movie title
        RAISE NOTICE 'Movie Title: %', movie_title;
    END LOOP;
    
    -- Close the cursor
    CLOSE movie_cursor;
END;
$$;

———————————————————————————————————————————————————————————————————————————

Create a function to calculate the average salary of employees of deptid given by the user.
Consider schema:
employees ( employee_id, name, department_id departments, salary, hire_date )

-- Create the table
CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    name VARCHAR(255),
    department_id INT,
    salary NUMERIC,
    hire_date DATE
);

-- Function to calculate average salary
CREATE OR REPLACE FUNCTION calculate_avg_salary(dept_id INT)
RETURNS NUMERIC AS $$
DECLARE
    avg_salary NUMERIC;
BEGIN
    -- Calculate the average salary for the given department ID
    SELECT AVG(salary)
    INTO avg_salary
    FROM employees
    WHERE department_id = dept_id;
    
    -- Return the average salary
    RETURN avg_salary;
END;
$$ LANGUAGE plpgsql;

-- Example usage:
-- SELECT calculate_avg_salary(1); -- Replace 1 with the department ID you want to query


                    </pre>
                <button onclick="copyText('qa1')" class="dark">Copy</button>
            </div>

            

            <!-- Add more question and answer pairs as needed -->
        </div>
    </div>

    <script>
        function copyText(elementId) {
            const range = document.createRange();
            const element = document.getElementById(elementId);
            range.selectNodeContents(element);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);

            try {
                document.execCommand('copy');
                alert('Copied to clipboard');
            } catch (err) {
                alert('Failed to copy');
            }
            selection.removeAllRanges(); // Clear selection
        }

        function copyAll() {
            const preElements = document.querySelectorAll('.qa-item pre');
            let allText = '';
            preElements.forEach(pre => {
                allText += pre.textContent + '\n\n';
            });
            navigator.clipboard.writeText(allText).then(() => {
                alert('All questions and answers copied to clipboard');
            }).catch(() => {
                alert('Failed to copy all');
            });
        }

        function toggleTheme() {
            const body = document.body;
            const container = document.querySelector('.container');
            const copyAllButton = document.querySelector('.copy-all');
            const toggleThemeButton = document.querySelector('.toggle-theme');
            const preElements = document.querySelectorAll('pre');
            const copyButtons = document.querySelectorAll('.qa-item button');

            body.classList.toggle('dark');
            body.classList.toggle('light');

            container.classList.toggle('dark');
            container.classList.toggle('light');

            copyAllButton.classList.toggle('dark');
            copyAllButton.classList.toggle('light');

            toggleThemeButton.classList.toggle('dark');
            toggleThemeButton.classList.toggle('light');

            preElements.forEach(pre => {
                pre.classList.toggle('dark');
                pre.classList.toggle('light');
            });

            copyButtons.forEach(button => {
                button.classList.toggle('dark');
                button.classList.toggle('light');
            });

            if (body.classList.contains('dark')) {
                toggleThemeButton.textContent = '☀';
            } else {
                toggleThemeButton.textContent = '🌙';
            }
        }
    </script>
</body>
</html>

